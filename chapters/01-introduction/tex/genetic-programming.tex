\section{Genetic programming}
% -- Very high-level literature review --

% -- What is genetic programming? --

% --- Relationship to GP ----
% @AML: needs better transition in/out of this paragraph
Both digital evolution and genetic programming systems evolve populations of computer programs, but each does so with different objectives.
Digital evolution aims to use computer programs as model organisms for evolution experiments, whereas genetic programming aims to synthesize computer programs to solve computational problems.
As such, GP systems often strip away some of the biological realism inherent to digital evolution systems to increase efficiency, and [GP more directly steers populations to promising regions of the fitness landscape].

% --- GP algorithm ---
While GP systems can differ dramatically in how they synthesize programs, most follow the same overarching recipe \citep{ofria_avida:_2009}:

% @AML: cheap way to set off the list
\begin{displayquote}
\begin{enumerate}
    \item Initialize a population of programs (with randomly generated programs or with [hand-designed] programs).
    \item Evaluate each program's quality relative to one or more criteria.
    \item Select promising programs to contribute genetic material to the next generation based on their quality.
    \item Vary selected programs by mutating or recombining them to produce the next generation of programs. 
    \item Repeat this process from step two until a sufficiently good program is generated.
\end{enumerate}
\end{displayquote}

% -- many GP representations --
Just as human software developers have access to an enormous variety of programming languages, each specialized for solving different types of problems, GP features many ways to represent evolvable programs.
Each representation features different programmatic elements that vary in their syntax, organization, interpretation, and evolution.
These differences can dramatically influence the types of computer programs that can be evolved, and as such, influence a representation's problem-solving range \citep{hintze_buffet_2019,wilson_comparison_2008}. 

% --- forms/representations (non-exhaustive) ---
% Alan Turing discussed using evolution as a means of programming computers to be able to imitate human intelligence a 1950 essay on machine intelligence [turing].

% -- Tree-based GP --
The earliest examples of successfully evolving computer programs used tree-based representations \citep{forsyth_beagle_1981,koza_hierarchical_1989}.
In tree-based GP, programs are organized as abstract syntax trees (Figure [XX]) \citep{poli_field_2008}.
The leaves of a tree are inputs or constants (i.e., terminals) and the internal nodes are arithmetic operations (e.g., addition, multiplication, \textit{etc.}).
Trees can be executed bottom-up; [that is, the bottom-most operations can be executed first using their associated terminals as inputs, the results of which can be propagated up the tree and so on.] 
Since the early success of tree-based GP, a wide range of GP representations have been developed, including graph-based GP \citep{miller_empirical_1999,kelly_multi-task_2017}, linear GP \citep{brameier_linear_2007}, and stack-based GP \citep{perkis_stack-based_1994,spector_autoconstructive_2001}. 

In my work, I focus on [making representations more dynamic and easier to evolve plasticity] in context of linear GP.
Perhaps more familiar to software developers, linear GP representations organize programs as linear sequences of instructions.
Linear genetic programs traditionally follow an imperative paradigm where computation is driven procedurally, often starting at the top of the program and proceeding in sequence, instruction-by-instruction, jumping or branching as dictated by executed instructions.




% -- application areas --
% - symbolic regression - often tree-based gp, graph-based gp
% - bug fixing - knowledge of linear gp and GE(?)
% - program synthesis - stack-based gp, linear gp

% -- benefits over for example neural networks --
% - transparency
% - efficient => computers are designed to run computer programs, so GP can run on existing hardware at a very low level

% -- Graph-based GP --
% Graph-based GP directly extends tree-based GP, representing programs as graph structures (e.g., Cartesian GP \citep{miller_empirical_1999} or Tangled program graphs \citep{kelly_multi-task_2017}).
% [executing graph-based gp - particular representation must define a starting point and how to deal with internal cycles].
% -- stack-based gp --
% In stack-based GP representations, programs operate over data stacks.
% In the first stack-based representation introduced by Perkis, programs were represented as LISP s-expression that operated over a single numeric data stack \citep{perkis_stack-based_1994}.
% PushGP, another stack-based representation, supports multiple data types by including typed 

% -- my work --
% - In my work, I focus on developing new ways to represent programs to make it easier to evolve programs capable of complex forms of plasticity.
% - (1) modules with evolvable labels
% - (2) allowing signals to automatically trigger modules
% - (3) allowing programs to adjust links between modules on the fly
% - (4) developing more flexible ways of memory access

