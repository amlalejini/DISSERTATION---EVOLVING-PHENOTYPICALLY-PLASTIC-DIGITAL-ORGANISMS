
\section{Specifying Modules with Tag-based Referencing}
\label{chapter:tag-based-regulation:sec:tag-based-referencing}
% Alternatively, just 'Tag-based Referencing'

% - motivation for evolvable names -
All programming representations that support modularizing code into functions or libraries define mechanisms for labeling and subsequently referencing modules. 
In traditional software development, programmers hand label modules and reference a particular module using its assigned label.
Programmers must precisely name the module they intend to reference; imprecision typically results in incorrect outputs or a syntax error. 
This mechanism for referencing modules allows for an arbitrarily large space of possible module names and is intentionally brittle, ensuring programs are either interpreted by a computer exactly as written or not interpreted at all. 
Requiring genetic programming systems to adhere to these traditional approaches to module referencing is not ideal. 
Mutation operators must either ensure that mutated labels are syntactically valid, or else cope with an abundance of broken code.
These choices result in either a search space that is overly constrained or one that is rugged and difficult to navigate \citep{rasmussen_coreworld_1990}.

% - tag-based referencing (definition) -
Inspired by Holland's use of ``tags'' to facilitate binding and aggregation in complex adaptive systems \citep{holland_concerning_1990,holland_effect_1993}, %XXX implemented [citations] and then 
Spector \textit{et al.} generalized the use of tags to label and refer to program modules in GP \citep{spector_tag-based_2011,spector_whats_2011}.
Tags are evolvable labels that can be mutated, and the similarity (or dissimilarity) between any two tags can be quantified. 
Tags are most commonly represented as floating point or integer numeric values \citep{keijzer_run_2004,spector_tag-based_2011} or as bit strings \citep{lalejini_evolving_2018}.
Like traditional naming schemes, tags can provide an arbitrarily large address space.
Unlike traditional naming schemes, however, tags allow for \textit{inexact} addressing. 
A referring tag targets the tagged entity (\textit{e.g.}, a module) with the \textit{closest matching} tag; 
this ensures that all possible tags are valid references.
Further, mutations to tags do not necessarily invalidate existing references.
For example, mutating a referring tag will have no phenotypic effect if those mutations do not change which target tag is matched. 
As such, mutating tag-based names is not necessarily catastrophic to program functionality, allowing the labeling and use of modularized code fragments to incrementally co-evolve \citep{spector_tag-based_2011}.
%tag-based naming schemes allow the labeling and use of modularized code fragments to incrementally co-evolve \citep{spector_tag-based_2011}.

% - history/background for tag-based referencing -
Tag-based referencing has long been used to expand the capabilities of genetic programming systems.
Keijzer \textit{et al.} created Run Transferable libraries of tag-addressable functions using successful code segments evolved in previous GP runs \citep{keijzer_run_2004,keijzer_undirected_2005}.
Evolving programs (represented as program trees) contained dynamically-linked nodes that used tag-based referencing to call library functions.
These tag-addressed libraries were updated between runs and did not co-evolve with programs.

Spector \textit{et al.} augmented PushGP with tag-based referencing, allowing tag-addressable code modules to evolve \textit{within} a program \citep{spector_tag-based_2011}.
Spector \textit{et al.} found that tags provided a flexible mechanism for modularization that allowed tag-enabled programs to better scale with problem size. 
Additionally, Spector \textit{et al.} expanded tag-based modules beyond PushGP, successfully applying the technique to tree-based GP \citep{spector_tag-based_2012}.

Lalejini and Ofria further extended tag-based naming to linear GP.  
Their SignalGP system broadens the application of tags to facilitate the evolution of event-driven programs \citep{lalejini_evolving_2018,lalejini_what_2019}. 
In SignalGP, tagged modules are called internally or triggered in response to tagged events (\textit{e.g.}, events generated by other agents or the environment).
More recently, Lalejini and Ofria demonstrated the use of tags to label memory positions in GP, enabling programs to define and use evolvable variable names \citep{lalejini_tag-accessed_2019}.
This tag-based memory implementation did not substantively affect problem-solving performance; however, tag-based addressing features a larger addressable memory space than more traditional register-based memory approaches in GP.
% @AML: Anything from DISHTINY we should cite?